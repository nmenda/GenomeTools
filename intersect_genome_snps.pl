#!/usr/bin/perl

=head1 NAME

 intersect_genome_snps.pl
This script extracts the SNP intersection from 2 subsets of mpileup.intersect files, preferably generated with extract_snp_freq.pl.
A report will be generated with the number of similar SNPs removed from the target mpileup file, and the number of non-matchiing removed SNPs.
The criteria for extracting SNPs from the target file is a position which is unique, and does not have a SNP in the reference file.
This should hopefully remove SNPs that are shared between 2 genomes, and will leave potential SNPs that came from the target intersect file   

=cut

=head1 SYPNOSIS

 intersect_genome_snps.pl [-h] --target <input_mpileup_file> --intersect <input_intersecting_mpileup file(s , comma separated) >  -o <output_file>

=head1 DESCRIPTION

 This script reads 2 files generated by extract_snp_freq.pl: subset of mpileup file from a target genome and a reference genomes with sought SNPs, and anohter subset mpileup file of the same target genome and SNPs that should be filtered (for example a target file of an inbred genome filtered from SNPs from a close relative, and a second SNP file from anohter potential ancestor(s) that should be subtracted from the first set)  
 and a varscan file of a reference genome ( for example a possible donor for the target SNPs) .

Both files should have an extra column (#7) with the allele frequency from the target genome.
This allows to plot the SNPs of the target genome X reference genome minus the SNPs from a second reference genome.
This subtracting tage can be run multiple times, if you wish to look at each genome pair separately, each time removing non-specific SNPs of the reference species compared to one other genome.


=head2 I<Flags:>

=over

=item --target | t

B<input mpileup file>             input mpileup file of the target genome (mandatory)

=item --intersect | i

B<input mpileup file (s)>           input mpileup file(s) of a second genome (or more, comma separated lists are supported), to be removed from file #1 above 

    
=item -o

B<output_file>            output file (mandatory)


=item -h

B<help>                   print this help doc

=back

=head1 AUTHOR

Naama Menda<nm249@cornell.edu>

=cut



use strict;
use warnings;
use File::Slurp;

use Getopt::Long;
use Pod::Usage;
use Carp qw /croak/;

my ( $target_mpileup, @intersect_mpileup, $out, $help); 

GetOptions (
    "target|t=s"    => \$target_mpileup,    # string
    "intersect|i=s" => \@intersect_mpileup, # string
    "out=s"    => \$out,
    "help"  => \$help)   # flag
    or  pod2usage(-verbose  => 2);

if ($help || !$target_mpileup || !@intersect_mpileup || !$out)  { pod2usage(-verbose  => 2); } 

# list file is varscan with chr. in column 1 and position in clumn 2

open (TARGET, "<$target_mpileup") || die "Cannot open target mpileup file $target_mpileup.\n";

@intersect_mpileup = split(/,/,join(',',@intersect_mpileup));
my $err = $out . ".err" ;
my %intersect;

foreach my $file (@intersect_mpileup) {
    #remove trailing and leading spaces
    $file =~ s/^\s(.?)\s*/$1/;
    open (INTERSECT, "<$file") || croak "Cannot open intersect mpileup file $file.\n";
    print STDERR "Intersect file: $file \n\n";

    # parse the intersecting file 
    while ( <INTERSECT> ) {
	my $var_line = $_;
	chomp($var_line);
	my @var = split ("\t", $var_line);
	my $chr = $var[0];
	my $pos = $var[1];
	my $var_allele = $var[6];
	my $existing_allele = $intersect{$chr . ":" . $pos } ;
	my $allele_list = $var_allele;
	if ($existing_allele) { $allele_list = join("\t" , ( $existing_allele, $var_allele ) ) ; } 
	$intersect{$chr . ":" . $pos } = $allele_list;
	print STDERR " Intersect : $chr \t $pos \t allele = $allele_list \n";
    }
}


#print STDERR " Target : $chr \t $pos \t allele = $target_allele ";                                                                                                 

while ( <TARGET> ) {
    my $line = $_;
    chomp($line);
    my @tar = split ("\t", $line);
    my $chr = $tar[0];
    my $pos = $tar[1];
    my $target_allele = $tar[6];

    my $var_allele = $intersect{$chr . ":" . $pos };
    # if an allele exists in the same position in the intersect file, discard it. 
    # print in the error file both alleles for counting which alleles are identical and which are different 
    if ($var_allele) {
	write_file($err, {append => 1 } , ( ( join ("\t" , ( $chr, $pos, $target_allele, $var_allele) ) ) , "\n" ) ) ;
    } else {
	print STDERR " Target : $chr \t $pos \t allele = $target_allele \n";                                                                                        
	write_file($out, { append => 1} , ( $line,"\n")  );
    }
}

